---
title: 秋招准备
date: 2019-09-23 17:25:30
categories: "后端"
tags: ["秋招", "Java", "MySQL", "Spring", "微服务"]
---

## Java基础

### 自动装箱和拆箱

``` java
Integer a = 1;
Integer b = 2;
Integer c = 3;
Integer d = 3;
Integer e = 321;
Integer f = 321;
Long g = 3L;
Long h = 2L;
System.out.println(c == d);
System.out.println(e == f);
System.out.println(c == (a + b));
System.out.println(c.equals(a + b));
System.out.println(g == (a + b));
System.out.println(g.equals(a + b));
System.out.println(g.equals(a + h));
```

结果是

```shell
truefalsetruetruetruefalsetrue
```

对于前两个，记过很容易想到，`==`判断对象是否相等，而Integer中有个IntegerCache数组，保存了从-128 ~ 127的对象（上限可以根据JVM进行选择），所以没问题
第三个先进行拆箱计算`a + b`，然后比较数值是否相等，第四个拆箱后在进行自动装箱
倒数第二个`a + b`自动装箱为`Integer`，所以返回`false`，倒数第一个装箱为`Long`
装箱的代码是

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high) {
        return IntegerCache.cache[i + (-IntegerCache.low)];
    }
    return new Integer(i);
}
```

拆箱的代码是

```java
private final int value;
public int intValue() {
    return value;
}
```

### 在Java中定义一个不做事且没有参数的构造方法的作用

Java程序在执行子类构造方法之前，如果没有用`super()`来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中有没有`super()`来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。

### 多线程

#### 线程池 - 线程工程

实际的线程工作

```java
public class WorkRunnable implements Runnable {
    @Override
    public void run() {
        try {
            int r = (int) (Math.random() * 10);
            Thread.sleep(r * 1000);
            System.out.println(Thread.currentThread().getName());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

调用线程

```java
public class WorkThread extends Thread {
    private Runnable target;
    public WorkThread(Runnable target) {
        this.target = target;
    }
    @Override
    public void run() {
        try {
            target.run();
        } finally {
            System.out.println(target);
        }
    }
}
```

线程工厂

```java
import java.util.concurrent.ThreadFactory;

public class TaskFactory implements ThreadFactory {
    @Override
    public Thread newThread(Runnable r) {
        return new WorkThread(r);
    }
}
import java.util.concurrent.*;
public class Main {
    public static void main(String[] args) {
        //ExecutorService exec = new ThreadPoolExecutor(3, 3, 0L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
        ExecutorService es = Executors.newFixedThreadPool(3, new TaskFactory());
        for (int i = 0; i < 10; ++i) {
            es.execute(new WorkRunnable());
        }
        es.shutdown();
    }
}
```

## 算法

### 排序

| 排序法 | 平均时间   | 最差情形   | 稳定性 | 额外空间  |
| :----- | :--------- | :--------- | :----- | :-------- |
| 冒泡   | $O(n^2)$   | $O(n^2)$   | 稳定   | $O(1)$    |
| 交换   | $O(n^2)$   | $O(n^2)$   | 不稳定 | $O(1)$    |
| 选择   | $O(n^2)$   | $O(n^2)$   | 不稳定 | $O(1)$    |
| 插入   | $O(n^2)$   | $O(n^2)$   | 稳定   | $O(1)$    |
| 基数   | $O(logRB)$ | $O(logRB)$ | 稳定   | $O(n)$    |
| 快速   | $O(nlogn)$ | $O(n^2)$   | 不稳定 | $O(logn)$ |
| 归并   | $O(nlogn)$ | $O(nlogn)$ | 稳定   | $O(n)$    |

## MySQL

### MyISAM和InnoDB区别

- 是否支持行级锁：MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认行级锁
- 是否支持事务和崩溃后的安全恢复： MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB类型更快，单不提供支持事务支持。但是InnoDB提供事务支持，外键等高级数据库功能。具有事务、回滚和崩溃修复能力的事务安全型表
- 是否支持外键：MyISAM不支持，InnoDB支持
- 是否支持MVCC：仅InnoDB支持。

### 事务

逻辑上的一组操作，要么都执行，要么都不执行

#### 事务的四大特性（ACID）

- 原子性：事务时最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。
- 一致性：执行事务前后，数据保持一直，多个事务对同一个数据读取的结果时相同的
- 隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库时独立的
- 持久性：一个事务被提交后，它对数据库中数据的改变时持久的，即使数据库发生故障也不应该对其有任何影响。

#### 事务的问题

- 脏读：单一个事务正在访问数据，并对数据进行修改，而这种修改还没有提交到数据库中，这是另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”。
- 丢失修改：旨在要给事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据，这样第一个事务的修改结果就会丢失，因此成为丢失修改。
- 不可重复读：指在一个事务内多次读同一个数据。在一个事务还没有结束时，另一个事务也访问了该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据时不一样的，因此称为不可重复读。
- 幻读：与不可重复读类似。它发生在一个事务读取几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样。

#### 隔离级别

- 读未提交：最低的级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读、不可能重复读
- 读已提交：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生
- 可重复读：对同一字段的多次读取结果都是一致的，除非数据时被本身事务自己所修改，可以阻止脏读和不可重复读，单幻读仍有可能发生
- 可串行化：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，可以防止脏读、不可重复读、幻读

### 索引

索引是一种数据结构，能够帮助我们快速的建索数据库中的数据。主要结构有两种：Hash索引和B+数索引，InnoDB默认是B+树。

#### 为什么使用B+树，和Hash索引又哪些优缺点

Hash索引底层是哈希表，是KV存储的结构，所以数据在存储关系上没有顺序管理，所以区间查询无法直接通过索引查询，而是全表扫描。所以Hash索引只适用于等职查询的场景，无法进行排序。哈希索引不支持多列联合索引的最左匹配查询。由于有大量重复KV的情况下，会出现哈希碰撞问题，效率低  
B+树是一种多路平衡树，所以他的节点是天然有序的，所以对于范围查询不需要全表扫描

#### 聚簇索引

聚簇索引的叶子节点是数据节点，而非聚簇节点的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。  
聚簇索引的顺序就是硬盘上的物理顺序，一般情况下主键就是默认的聚簇索引。一张表只允许存在一个聚簇索引，因为真实数据的的物理顺序只能有一种。这就导致了聚簇索引的缺点：对表进行修改速度较慢。所以经常更新的列不宜建立聚簇索引。
聚簇索引默认是主键，如果表中没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式地定义一个主键来作为聚簇索引

#### 最左前缀匹配

即最左有限，在检索数据时从联合索引的最左边开始匹配，所以当我们创建一个联合索引的时候，如(key1, key2, key3)，相当于创建(key1)、(key1, key2)、(key1, key2, key3)三个索引

#### 常见命令

- explain 查看执行计划

## Spring

### 核心组件

- Beans
- Context
- Core

### bean

#### 生命周期

1. Spring 启动，查找并加载需要被Spring管理的bean，进行Bean的实例化
2. Bean实例化后对Bean的引用和值注入到Bean的属性中
3. 如果Bean实现了`BeanNameAware`接口，Spring将Bean的Id传递给`setBeanName()`方法
4. 如果Bean实现了`BeanFactoryAware`接口，Spring将调用`setBeanFacotry()`方法，将BeanFactory容器实例传入
5. 如果Bean实现了`ApplicationContextAware`接口的话，Spring将调用Bean的`setApplicationContext()`方法，将bean所在应用上下文引用传入进来
6. 如果Bean实现了`BeanPostProcessor`接口，Spring就将调用他们的`postProcessBeforeInitialzation()`方法
7. 如果Bean实现了`InitializingBean`接口，Spring将调用他们的`afterPropertiesSet()`方法。类似的，如果bean使用`init-method`声明了初始化的方法，该方法也会调用
8. 如果Bean实现了`BeanPostProcess`接口，Spring就将调用他们的`postProcessAfterInitialization()`方法
9. 此时，Bean已经准备就绪，可以被应用程序使用了，他们一直驻留在应用上下文中，直到应用上下文被销毁
10. 如果bean实现了`DisposableBean`接口，spring将调用他的`destory()`接口方法，同样如果bean使用了`destory-method`生命销毁方法，该方法也会被调用

## 微服务

微服务是结构是一种建构模式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调，相互配合，为用户提供最终的价值

### 特点

- 小：粒度小，且专注一件事情
- 独：单独的进程
- 轻：轻量级通信机制，通常是HTTP/REST接口
- 松耦合，可独立部署

#### 优点

- 提升开发交流，每个服务足够内聚，足够小，代码容易理解
- 服务独立测试、部署、升级、发布
- 按需定制的DFX，资源利用率，每个服务可以各自进行x扩展和z扩招，而且，每个服务可以根据自己的需求部署到合适的硬件服务器上；每个服务按需要选择HA模式，选择接收服务的实例个数
- 如意扩大开发团队，可以针对每个服务（service）组件开发团队
- 提高容错性，一个服务的内存泄露并不会让这个系统瘫痪
- 新技术的应用，系统不会被长期限制在某个技术栈上

> `DFX = Design for X`表示面向产品非功能性属性的设计，其中“X”代表产品生命周期或其中某一环节，如供应、安装、维护等，也可以代表产品竞争力或决定产品竞争力的因素，如可靠性、节能减排、网络安全性等。
> HA模式：高可用模式

#### 缺点

- 没有银弹，微服务提高了系统的复杂度
- 开发人员要处理分布式系统的复杂性
- 服务之间的分布式通信问题
- 服务的注册与发现问题
- 服务之间的分布式事务问题
- 数据隔离再来的报表问题处理
- 服务之间的分布式一致性问题
- 服务管理的复杂性，服务的编排
- 不同服务实例的管理

> x轴：服务实例水平扩展，保证可靠性与性能
> y轴：功能的扩展，服务单一职责，功能独立
> z轴：数据分区，数据独立，可靠性保证

### 服务的发现与注册

一般的微服务架构里都有两层API GateWay，一层是外部的API，用于用户访问系统，一层是内部API，解决的问题就是服务发现和服务注册
怎么找到一个服务，有两个思路：客户端发现，客户端去注册中心查询服务实例列表，自行选择；添加LB模块，客户端把请求法相LB，由LB根据负载均衡策略选择服务实例。

### 注册中心

一个服务可以有多个实例，那么我们在向一个服务发出请求的时候，怎么知道这个服务有哪些实例呢，为了减少手工维护的麻烦，我们需要服务注册中心。每个服务实例在启动时向注册中心注册自己的IP地址等信息。这样服务在调用别的服务的接口时，就可以通过注册中心，查询到其他服务的实例，向实例发起请求。

## dubbo

### 演化过程

#### 一个简单的服务调用方式

调用方与服务方约定请求参数字段和请求结果字段，服务方气功一个tomcat+springmvc，监听80端口，调用方通过httpclient发起http请求，服务方返回json或xml数据结果，调用方拿到http相应结果解析数据，一次服务调用结束

### 通过注册中心发现服务，client端完成负载均衡

服务方在启动tomcat后，向注册中心注册自己的服务列表，包括服务器ip、port，以及代表服务的唯一标识，比如以格式/a_service/ip_port存储在注册中i性能。
调用方在启动后，去注册中心寻找a服务的地址列表，并且订阅/a_service，当a服务列表变更就会将消息推给调用方，接下来地址列表得到了，调用方创建了多个HTTP client实例，每个实例对应一个服务器的ip_port，每次发起调用，从HTTP client实例列表中随机选择一个，发起调用请求。当服务器某台服务器出现当即或者网络故障，调用方会从由注册中心推送过来的通知消息，将而将出现故障的ip_port对应的HTTP client从列表中移除，当服务方新增加服务器时，调用方同样会收到通知消息，进而新建HTTP client实例，加入HTTP client列表。由此我们增加了注册中心集群，在服务方调用方加入注册中心客户端

### 负责均衡策略模块

服务方将权重信息写入注册中心，调用方取到后根据自己或者服务方建议的负载均衡策略从HTTP client列表中选择一个实例，进而发起http请求。

## HTTP

### 浏览器中输入URL地址到显示网页的过程

- [在浏览器中输入URL](#url)
- [DNS域名解析](#dns)
- [TCP连接](#tcp)
- [服务器处理请求](#server)
- [网站处理流程](#mvc)
- [浏览器显示页面信息](#show)

<h4 id="url"> 在浏览器输入URL</h4>
URL，统一资源定位符，由一串简单的文本字符组成，它的作用是位于定位互联网上资源的地址。URL通常由一下几部分组成：  

##### 协议部分

通过特定的传输协议，获得指定文档的内容。在Internet中可以使用多种协议。常见有：  

- "http" 超文本传输协议
- "https" 进行加密的网络传输协议
- "file" 本地文件传输协议
- "ftp" 文件传输协议
- "mailto" 资源为电子邮件地址，通过SMTP访问

<h4 id="dns"> 域名部分</h4>
用于来确定服务器在互联网的位置，域名的木丁是便于记忆和沟通的一组服务器的地址，是唯一不可重复的.  
##### 端口部分
跟在域名后面的端口编号，域名和端口之间使用”:”分隔。默认端口一般在URL中不展现，当web服务器采用的不是默认端口时，就需要写明服务所在的端口。端口号的作用主要是区分服务类型和在同一时间进行多个会话。常见县议和接口号如下：  
| 应用协议 | 端口号 |
| :-------| :------ |
| http | 80 |
| ftp | 21 |
| https | 443 |
| smtp | 25 |
| tftp | 69 |
| telnet | 23 |

##### 文件路径

一般用来表示主机上的一个目录或文件地址，由零或多个”/“符号隔开，划分为多个层次进行描述  

#### DNS域名解析

当输入URL后，电脑会发出一个DNS请求，将域名转化为IP地址的请求。

##### DNS 域名系统

主要进行将主机名和域名转换为IP地址的工作。把便于用户记忆的特定域名转换成为能够被极其直接读取的IP数串

##### 域名解析流程

- 查询浏览器缓存
- 查询系统缓存
- 查询路由器缓存
- 查找ISP DNS缓存
- 根域名服务器

<h4 id="tcp">TCP连接</h4>

##### 应用层：发送HTTP请求

前面的步骤我们已经得到了IP地址，浏览器会开始构造一个HTTP报文，包括：

- 请求报头：请求方法、目标地址、遵循的协议等等
- 请求主体（其他参数）

##### 传输层：TCP传输报文

传输层会发起一条到达服务器的TCP连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号。

##### 网络层：IP协议查询Mac地址

将数据段打包，并加入源及目标的IP地址，并且负责寻找传输路线。
根据目标地址是否与当前地址处于同一网络中，有的话直接根据Mac地址发送，否则使用路由表查询下一跳地址，以及ARP协议查询Mac地址。

##### 链路层：以太网协议

根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两部分：

- 表头：数据包的发送者、接受者、数据类型
- 数据：数据包具体内容

<h4 id="server">服务器处理请求</h4>
有服务器上安装的处理请求的应用来处理，常见的有：Apache、Nginx、IIS。它会监听得到的请求，然后开启一个子进程去处理这个请求。

##### 处理请求

接收到TCP报文后，会对连接进行处理，对HTTP协议进行解析，并且进行验证：

- 验证是否配置虚拟主机
- 验证虚拟主机是否接收此方法
- 验证该用户可以使用该方法

##### 重定向

加入服务器配置了HTTP重定向，就会返回一个301永久重定向响应，浏览器就会根据相应，重新发送HTTP请求。
<h4 id="mvc"> 网站处理流程</h4>
服务器收到请求后出发Controller，Controller会获取各种数据进行处理
<h4 id="show">浏览器显示页面信息</h4>

- HTML字符串被历览器接收后被一句句读取解析。
- 解析到link标签后重新发送请求获取css
- 解析到script标签后返送请求获取js，并执行代码
- 解析到img标签后发送请求获取图片资源
- 浏览器根据HTML和CSS计算得到渲染书，绘制到屏幕上。
- JS会被执行，页面展现。

## 面经问题

### 数据库

#### 有一个一千万的用户表，把性别从男女更新成01，怎么写sql

根据id分片，然后批量update
