---
title: 实习准备
date: 2019-04-23 17:25:30
categories: "后端"
tags: ["实习", "Java", "数据结构"]
---

# 网上的面经问题与回答

## 树

### 二叉树

- 前序遍历：根节点->左节点->右节点
- 中序遍历：左节点->根节点->右节点
- 后序遍历：左节点->右节点->根节点

### 红黑树 O(log n)

#### 特性

1. 节点是红色或黑色
2. 根节点是黑色
3. 每个叶子节点都是黑色的空节点（NIL节点）
4. 每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能由两个连续的红色节点）
5. 从任意节点到其每个叶子的所有路径都包含相同数目的黑色节点
![avatar](https://ncabhd.github.io/picture/RedBlackTree.jpg)

#### 插入

插入新节点时，该节点是红色。设该节点为N，N的父节点为P，祖父节点为G，叔叔节点为U。插入红色节点后，会出现5种情况

1. 插入新节点N是红黑树的根节点，将节点N的颜色变成黑色
![avator](https://ncabhd.github.io/picture/RBTreeInsertOne.png)
2. N的父节点P是黑色，不需要调整
![avator](https://ncabhd.github.io/picture/RBTreeInsertTwo.png)
3. N的父节点是红色（节点P为红色，其父节点必然是黑色），叔叔节点U也是红色。由于P和N均为红，所以需要进行调整。此时先将P和U染成黑色，再将G的颜色染成红色。此时经过G的路径上的黑色节点数量不变，但G被染成红色后，可能会和它的父节点形成连续的红色节点，需要递归向上调整
![avator](https://ncabhd.github.io/picture/RBTreeInsertThree.png)
4. N的父节点是红色，叔叔节点时黑色。节点N时P的右孩子，且节点P时G的左孩子。此时先对节点P进行左旋，调整N和P的位置。接下来以恢复性质4
![avator](https://ncabhd.github.io/picture/RBTreeInsertFour.png)
这里说明以下，上图中的节点N并非是新插入的节点。当P为红色时，P由两个孩子节点，且孩子节点均为黑色，这样从G出发到各叶子节点路径上的黑色节点数量才能一致。既然P已经由两个孩子了，所以N不是新插入的节点。是以N为跟姐底单的子树中插入了新节点，经过调整后，导致N被变成红色
5. N的父节点是红色，叔叔节点是黑色，N是P的左孩子，且节点P是G的左孩子。此时对G进行右旋，调整P和G的位置，并互换颜色。
![avator](https://ncabhd.github.io/picture/RBTreeInsertFive.png)
总结
![avator](https://ncabhd.github.io/picture/RBTreeInsert.jpg)

## 字符串

### String

#### 设计成不可变的好处

##### 安全性

###### 多线程安全

因为String是不可变的，因此在多线程操作下，它是安全的

```java
public String get(String str) {
    str += "aaa";
    return str;
}
```

###### 类加载中体现的安全性

类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载

##### 使用常量池节省空间

只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串时可变的，那么String interning（对不同的字符串仅仅只保存一个）将不能实现。因为这样的话，如果变量改变了它的值，那么其他指向这个值的值也会一起改变

##### 缓存hashcode

因为字符串时不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map的键，字符串的处理速度要快过其他的键对象。

## 集合

### HashMap

#### Put方法的原理

例如调用hashMap.put(“apple”, 0)，插入一个Key为”apple”的元素。这时候我们需要利用一个哈希函数来确定Entry的插入位置(index)。当插入的Entry越来越多，出现index冲突的情况，利用链表来解决，并采用“头插法”，因为发明者认为后插入的Entry被查找的可能性更大(jdk1.7)

#### Get方法的原理

先把输入的Key做一个Hash映射，得到对应的index。由于index冲突，同一个位置可能匹配到多个Entry，这时候就需要顺着对应链表的头节点，一个一个向下查找

#### 容量

HashMap的默认初始长度是16，且每次自动拓展或是手动初始化时，长度必须是2的幂。因为HashCode采用位运算 $ index = HashCode(key) & (Length - 1) $ ，可以说Hash算法最终得到的index结果完全取决于Key的HashCode值的最后几位。

#### 扩容

Resize的因素有两个，Capacity（HashMap的当前长度）和LoadFactor（HashMap负载因子，默认值为0.75f）
衡量HashMap是否进行Resize的条件 $ HashMap.Size >= Capacity * LoadFactor $
步骤：

1. 扩容
创建一个新的Entry空数组，长度是原数组的2倍
2. ReHash
里边原Entry数组，把所有的Entry重新Hash到新数组，因为长度扩大以后，Hash的规则也随之改变

#### 为什么重写equals()方法的时候要重写hashCode()方法

在使用HashMap的时候，Key部分使用自定义对象，只重写equals()是不行的，因为在put的时候先使用hashCode()方法，两个new出来的对象的hash值不同，就会插入两个相同的key

### ConcurrentHashMap

在JDK8之前采用分段锁的设计理念，相当于Hashtable 与HashMap的折中版本，这是效率与一致性权衡后的结果。分段锁是由内部类Segment实现的，它继承于ReentrantLock，用来管理它辖区的各个HashEntry。ConcurrentHashMap被Segment分成很多小区，Segment就相当于小区保安，HashEntry列表相当于小区业主，小区保安通过加锁的方式，保证每个Segment内部不发生冲突
JDK11版本对ConcurrentHashMap与JDK7进行三点改进

1. 取消分段锁机制，进一步降低冲突概率，采用CAS + synchronized
2. 引入红黑树结构。同一个哈希槽上的元素个数超过要给阈值后，单向链表改为红黑树结构
3. 使用了更加优化的方式统计集合内的元素数量。首先Map原有的size()方法最大只能表示 $ 2^{31} -1$ ，ConturrentHashMap额外提供了mappingCount()方法，用来返回集合内元素的数量，最大可以表示 $ 2^{63} -1 $。此外在元素更新时，使用了CAS和多种优化以提高并发能力。从图中可以看出，table的长度为64，数据存储结构分为两种：链表和红黑树。当某个槽内的元素个数增加到超过8个且table的容量大于或等于64时，由链表转为红黑树；当某个槽内的元素个数减少到6个时，由红黑树重新转回链表。需要注意的时，当table的容量小于64时，只会扩容，并不会把链表转为红黑树。在转化过程中，使用同步块锁住当前槽的首元素，防止其他进程对当前槽进行增删改操作，转化完成后利用CAS替换原有链表。

## 匿名类

匿名类相当于在定义类的同时再新建这个类的实例

### 访问权限

#### 可以访问

1. 访问外层Class里面的字段
2. 不能访问外层方法中的本地变量，除非变量是final
3. 如果内部类的名称和外面能访问的名称相同，则会把名称覆盖掉

#### 不能存在

1. 不能定义静态初始化代码块（Static Initializer）
2. 不能再匿名类里面定义接口
3. 不能再匿名类中定义构造函数

### 为什么必须是final

内部类会自动拷贝外部变量的引用，为了避免：

1. 外部方法修改引用，而导致内部类得到的引用值不一致
2. 内部类修改引用，而导致外部方法的参数值在修改前和修改后不一致。于是就用 final 来让该引用不可改变。

## JVM

### 对象的创建

1. 类加载检查
2. 分配内存
3. 初始化零值
虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）
4. 设置对象头
5. 执行init方法

### 类加载过程

双亲委派模型
类加载器是一个运行时核心基础设施模块，主要在启动之初进行类的Load、Link 和Init，即加载、链接、初始化。
第一步，Load阶段读取类文件产生二进制流，并转化为特定的数据结构，初步校验cafe babe魔法数、常量池、文件长度、是否有父类等；然后创建对应类的java.lang.Class实例。
第二步，Link阶段包括验证、准备、解析三个步骤。验证时更详细的校验，比如final是否合规、类型是否正确、静态变量是否合理等；准备阶段时为静态变量分配内存，并设定默认值，解析类和方法确保类与类之间的相互引用正确性，完成内存结构布局。
第三步，Init 阶段执行类构造器clinit方法，如果赋值运算时通过其他类的静态方法来完成的，那么会马上解析另外一个类，在虚拟机栈中执行完毕后通过返回值进行赋值
类加载器类似于原始部落结构，存在权力等级制度。第二、三层类加载器为Java语言实现，用户也可以自定义类加载器。
最高一层是家族中为王最高的Bootstrap，它是在JVM启动时创建的，通常由与操作系统相关的本地代码实现，是最根基的类加载器，负责装在最核心的Java类，例如Object、System、String等；
第二层是在JDK9版本中称为Platform ClassLoader，即平台类加载器，用以加载一些扩展的系统类，比如XML、加密、压缩相关的功能类，JDK9之前的加载器是Extension ClassLoader；
第三层是Application ClassLoader的应用类加载器，主要是加载用户定义的CLASSPATH路径下的类。
PlatformClassLoader的Parant为BootStrap，它是用过C/C++实现的，并不存在与JVM体系内。类加载器具有等级制度，但并非继承关系，以组合的方式来服用父加载器的功能，这也符合组合优先原则。
![avatar](https://ncabhd.github.io/picture/ClassLoad.png)
低层次的当前类加载器，不能覆盖更高层次类加载器已经加载的类。如果低层次的类加载器想加载一个未知类，要向上逐级询问：“请问：这个类已经加载了么？”被询问的高层次类加载器会自问两个问题：第一，我是否已加载过此类？第二，如果没有，是否可以加载此类？只有当所有高层次类加载器在两个问题上的答案均为“否”时，才可以让当前类加载器加载这个未知类.

### 内存

#### Heap（堆）

堆存储着几乎所有的实例对象，堆由垃圾收集器自动回收，堆区由各子线程共享使用。通常情况下，它占用的空间是所有内存区域中最大的，但如果无节制低创建大量对象，也容易消耗完所有的空间。堆的内存空间既可以固定大小，也可以运行时动态低调整。但是在通常情况下，服务器在运行过程中，堆空间不断地扩容与回缩，势必形成不必要的系统压力，所以线上生产环境中，Xms（最小堆容量）和Xmx（最大堆容量）设置成一大小，避免在GC后调整堆大小时带来的额外压力。
堆分成两大块：新生代和老年代。对象产生之初在新生代，不如暮年时进入老年代，但是老年代也接纳在新生代无法容纳的超大对象。新生代 = 1个Eden区 + 2个Survivor区。绝大部分对象在Eden区生成，当Eden区装填满的时候，会触发YGC。垃圾回收的时候，在Eden区实现清除策略，没有被引用的对象则直接回收。依然存活的对象会被移送到Survivor区，这个区是名副其实的存在。Survivor区分为S0和S1两块内存空间，送到哪个空间呢？每次YGC的时候，它们将存活的对象复制到未使用的那块空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态。如果YGC要移送的对象大于Sunvivor区容量的上限，则直接移交至老年代。每个对象有一个计数器，每次YGC都会加1，当到达某个阈值的时候（默认15），对象从新生代晋升至老年代。
![avatar](https://ncabhd.github.io/picture/heap.jpg)
如果Survivor区无法放下，或者超大对象的阈值超过上限，则尝试在老年代中进行分配，如果老年代也无法放下，则会触发FGC。如果依然无法放下，则抛出OOM

#### JVM Stack（虚拟机栈）

先进先出结构，栈帧在整个JVM体系中的地位颇高，包括局部变量表、操作栈、动态连接、方法返回地址等

1. 局部变量表
局部变量表是存放方法参数和局部变量的区域。相对于类属性变量的准备阶段和初始化阶段来说，局部变量没有准备阶段，必须显式初始化。如果是非静态方法，则在index[0]位置上存储的方法所属对象的实例引用，随后存储的是参数和局部变量。字节码指令中的STORE指令就是将操作栈中计算完成的局部变量写进局部变量表的存储空间内
2. 操作栈
操作栈是一个初始状态为空的筒式结构栈。在方法执行过程中，会有各种指令往栈中写入和提取信息。JVM的执行引擎室基于栈的执行引擎，其中的栈值得是操作栈
3. 动态连接
每个栈帧中包含以恶在常量池中对当前方法的引用，目前是支持方法调用过程的动态连接
4. 方法返回地址
方法执行时有两种退出情况：第一，正常退出，即正常执行到任何方法的放回字节码；第二，异常退出。无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧，退出可能有三种方法：

- 返回值压入上次调用栈帧
- 异常信息抛出给能够处理的栈帧。
- PC计数器只想方法调用后的下一条指令

#### Native Method Stacks（本地方法栈）

#### Program Counter Register（程序计数寄存器）

寄存器存储指令相关的现场信息，由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。这样必然会导致经常终端或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器用来存放执行指令的偏移量和行号指示器等，线程执行或恢复都要依赖程序计数器。程序计数器在各个线程之间互不影响，此区域也不会发生内存溢出异常。

### 垃圾回收

为了判断对象是否存活，JVM引入了GC Roots。如果一个对象与GC Roots之间没有直接或间接的引用关系，比如某个失去任何引用的对象，或者两个互相环岛状循环引用的对象时，判决这些对象“死缓”，是可以被回收的。什么对象可以作为GC Roots呢？比如：类静态属性中引用的对象、常量引用的对象、虚拟机栈中引用的对象、本地方法栈中引用的对象。

#### 垃圾回收的相关算法

最基础的为“标记 - 清除算法”，该算法会从每个GC Roots触发，一次标记有引用关系的对象，最后将没有被标记的对象清楚。但是这种算法会带来大量的空间碎片，导致需要分配较大连续空间时容易触发FGC。
为了解决这个问题，又提出了“标记 - 整理算法”，该算法类似计算机的磁盘整理，首先会从GC Roots出发标记存活的对象，然后将存活对象整理到内存空间的一端，形成连续的已使用空间，最后把已使用空间之外的部分全部清理掉，这样就不会产生空间碎片的问题。
“Mark-Copy”算法，为了能够并行地标记和整理将空间分为两矿，每次只激活其中一块，垃圾回收时只需把存活的对象复制到另一块未激活空间上，将未激活空间标记为已激活，将已激活空间标记为未激活，然后清除原空间中的原对象。堆内存空间分为较大的Eden和两块较小的Surviver，每次只使用Eden和Survivor区的一块。这种情况下的“Mark-Copy”减少了内存空间的浪费。“Mark-Copy”现作为主流的YGC算法进行新生代的垃圾回收

#### 垃圾回收器

是实现垃圾回收算法并应用在JVM环境中的内存管理模块。

##### Serial回收器

一个主要应用于YGC的垃圾回收器，采用穿行单线程的方式完成GC任务，其中“Stop The World”简称STW，即垃圾回收的某个阶段会暂停整个应用程序的执行。FGC的时间相对较长，频繁FGC会严重影响应用程序的性能。

##### CMS回收器

回收停顿时间比较短、目前比较常用的垃圾回收器。它通过初始标记（Initial Mark）、并发标记（Concurrent Mark）、重新标记（Remark）、并发清除（Concurrent Sweep）四个步骤完成垃圾回收工作。在第1、3步的初始标记和重新标记阶段依然会引发STW，而第2、4步的并发标记和并发清除两个阶段可以和应用程序并发执行，也是比较耗时的操作，但并不影响应用程序的正常执行。由于CMS采用的是”标记 - 清除算法“，因此产生大量的空间碎片。为了解决这个问题，CMS可以强制JVM在FGC完成后对老年代进行压缩，执行一次空间碎片整理，但是空间碎片整理阶段也会因为STW。为了减少STW次数，CMS可以在执行n次FGC后，在JVM再在老年代执行空间碎片整理。

##### Hotspot

在JDK7中退出的新一代G1（Garbage-First Garbage Collector）垃圾回收。与CMS相比，G1具备压缩功能，能避免碎片问题，G1的暂停时间更加可控。
![avatar](https://ncabhd.github.io/picture/G1.jpg)
回收模型内存布局
G1将Java堆空间分割成了若干相同大小的区域，即region，包括Eden、Survivor、Old、Humongous四种类型。其中Humongous是特殊的Old类型，专门放置大型对象。这样的划分方式意味着不需要一个连续的内存空间管理对象。G1将空间分为多个区域，优先回收垃圾最多的区域。G1采用的是”Mark-Copy“，有非常好的空间整合能力，不会产生大量的空间碎片。G1的一大又是在于可预测的停顿时间，额够尽可能快地在指定时间内完成垃圾回收任务

## 线程池

在并发请求数量过多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。那么有没有一种办法能让线程执行完一个任务后并不销毁，而是可以继续执行其他任务？？这就是线程池的目的。

### 什么时候使用线程池

- 单个任务处理时间比较短
- 需要处理的任务数量大

### 使用线程池的好处

- 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗
- 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- 提高线程的可管理性。线程时稀缺资源，如果无限制的创建，不经会消耗系统资源，还会降低系统的稳定性，使用线程池可以机型统一的分配，调优和监控。

## 智力题

### 有很多蜡烛，每根蜡烛1小时，求15分钟怎么计时

### 五对夫妇问题

因为握手8次的老哥与其他所有人都握手了，所以其他人的握手次数不能为0，所以0和8时一对，问题就变成了四对夫妇，0、1、2、3、4、5、6、7次握手

### 赛马

### 加油问题

### 汉诺塔

### 3升水

## 酷家乐

1. 熟悉的数据结构说一说
数组、链表、队列、栈、树、图、散列表
2. 讲一下树
树是由一个根节点为基础，分出一个或多个子节点，像现实中的树一样的数据结构
3. 讲一下二叉树和二分搜索的区别
二叉树在插入的时候可以直接添加子节点的，而二分搜索添加数据后要新建数组
二分查找物理内存必须连续，二叉树不用？
4. hashmap为什么不用二叉树
在Java8后单链表长度大于8的时候转为红黑树，红黑树的插入比平衡二叉树效率高，读取比普通的二叉树高，性能相对折中使用红黑树
5. 相比二叉树，其他的什么树比较好
平衡二叉树、红黑树
6. 讲一下B+树查找key的整个流程
7. LinkedList判断是否有环
快慢指针，慢指针一次走一步，快指针一次走两步，如果有环，则一定会在环内相遇；如果没有环，快指针会先到达链表的尾部
8. 购票系统
9. 怎么判断入环点
假设x为环前的路程，a为环入口到相遇点的路程，c为环的长度。
快指针的路程为 $ S_f = x + m * c + a $
慢指针的路长为 $ S_s = x + n * c + a $
所以

$$ 2 * S_{s} = S_{f} \
2 * (x + n * c + a) = x + m * c + a \
\begin {aligned}
x &= (m - 2 * n) * c -a \
&= (m - 2 * n - 1) * c + c -a
\end {aligned} $$
即环前路程为相遇点后的环内路程
10. 如果链表特别长，又没有环，map存了很多，占内存，怎么优化
采用红黑树，提高内存的利用率

# HTTP

## 一次完整的HTTP请求

- 建立TCP连接
  在HTTP工作之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接通过TCP来完成的。HTTP是比TCP更高层的应用层协议，根据规则，只有低层协议建立之后，才能进行更高层协议的连接。因此首先要建立TCP连接，一般端口号为80
- Web浏览器向Web服务器发送请求行
  一旦建立TCP连接，Web浏览器就会向Web服务器发送请求命令
- Web浏览器发送请求头
  浏览器发送请求命令之后，还要以头信息的方式向Web服务器发送一些别的信息，之后浏览器发送一空白来通知服务器，它已经结束该头信息的发送。
- Web服务器应答
  客户机向服务器发出请求后，服务器会向客户机回送应答，`HTTP/1.1 200 OK`，应答的第一部分是协议的版本号和应答状态码。
- Web服务器发送应答头
  服务器会随同应答向用户发送关于自己的数据及被请求的文档。
- Web服务器向浏览器发送数据
  Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，以Contetnt-Type应答头信息所描述的格式发送用户所请求的实际数据。
- Web服务器关闭TCP连接

## 问题

- 问：为什么要三次握手
  答：为了防止已失效的连接请求报文突然又传送到了服务端，因而产生错误。
- 问：为什么要四次分手
  答：TCP协议是一种面向连接、可靠的、基于字节流的运输层通信协议，是全双工模式，这意味着，当主机1发送FIN报文段是，主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了，但是主机1还是可以接收主机2的数据。当主机2也发送FIN的时候，就会终止这次TCP连接。

## HTTP状态码

|分类 | 分类描述 |
| :---- | :---- |
| 1** | 信息，服务器收到请求，需要请求着继续执行操作   |
| 2** | 成功，操作被成功接收并处理 |
| 3** | 重定向，需要进一步的操作以完成请求 |
| 4** | 客户端错误，请求包含语法错误或无法完成请求|
| 5** | 服务器错误，服务器在处理请求的过程中发生了错误 |

- 200 成功，服务器已成功处理了请求
- 304 未修改，自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容
- 404 未找到，服务器找不到请求的网页
- 408 请求超时，服务器等候请求时发生超时

# 资料

redis设计与实现
javaWeb技术内幕
headfirst 设计模式
并发编程的艺术
深入理解JVM
大型网站技术架构
牛客网刷题与面经