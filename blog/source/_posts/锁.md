---
title: 锁
date: 2019-04-13 17:25:30
categories: "后端"
tags: ["锁", "Java"]
---
# 锁
## 乐观锁 / 悲观锁
乐观锁对应生活中乐观的人总是想事情往好的方向发展；悲观锁对应生活中悲观的人总是想事情往坏的方向发展。
读的多，冲突几率小，乐观锁。
写的多，冲突几率大，悲观锁。
### 乐观锁
总是假设最好的情况，即每次去拿数据的时候都认为别人没有修改过，所以不会上锁。这样省去了锁的开销，加大了系统的吞吐量。在提交数据更新前，会检查该事务读取数据后有没有其他事务又修改了该数据（版本号、CAS），如果又更新的话，正在提交的事务回滚。
#### 优缺点
不会产生任何锁和死锁，省去了锁的开销。但如果两个事务都读取了某一行，经过修改后谢晖数据库，就会遇得到问题
### 悲观锁
总是假设最坏的情况，即每次去拿数据的时候都认为别人修改过，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。
#### 流程
> 对任意记录修改前，先尝试为该记录加上排他锁。
> 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。
> 如果加锁成功，那么就可以对记录做修改，事务完成后就会解锁了。
> 期间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。

#### 优缺点
悲观锁是“先取锁再访问的保守策略，为数据处理的安全提供了保证。但是在效率方面会产生额外的开销，还有增加产生死锁的机会。在只读型事务处理会增加系统负载，降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。
## 轻量级锁 / 偏向锁 / 重量级锁
JVM的内置锁（没有写过多线程并发，对这个理解并不好）
- 偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。
- 轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。
- 重量级锁：有实际竞争，且锁竞争时间长。
### 重量级锁
### 轻量级锁
减少无实际竞争情况下，使用重量级锁产生的性能消耗
使用轻量级锁时，不需要申请互斥量，仅仅将Mark Work中的部分字节CAS更新只想线程栈中的Lock Record。如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则说明已经有线程获得了轻量级锁，发生了锁竞争，接下来会膨胀为重量级锁
#### 缺点
- 如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁，那么维持轻量级锁的过程就成了浪费。

### 偏向锁
减少无进程且只有一个线程使用锁的情况下，使用轻量锁产生的性能。