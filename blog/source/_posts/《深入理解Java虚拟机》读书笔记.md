---
title: 《深入理解Java虚拟机》读书笔记
date: 2019-11-25 17:25:30
categories: ["Java", "读书笔记"]
tags: ["Java", "Java虚拟机", "读书笔记"]
---

# 《深入理解Java虚拟机》

## 第一部分 走进Java

### 第一章 走进Java

和其他Java书一样，先概述Java和历史，和别的书不同的是有介绍Java虚拟机的历史。  
Sun Classic VM，第一款商用Java虚拟机，只能使用纯解释器方式来执行Java代码，要使用JIT编译器就必须外挂，但外挂了JIT编译器，JIT就完全接管了虚拟机的执行系统，解释器不再工作。  

> JIT，Just-in-time，即时翻译。当Java执行runtime环境时，每遇到新的类型，JIT在此时会针对这个类进行编译，编译后的程式被优化成相对简短的原生指令码，使得这个程式的执行速度较原先解释性（将Java指令转译为对等的微处理器指令）要快一些，且会将翻译过的代码缓存起来以降低性能损耗。但是这样做有个缺点，虽然执行速度快了，但是编译时间变长。  
在Sun Classic中一旦外挂了JIT，代码运行一次也要经过编译，无论它们执行的频率是否有价值去编译。这就导致了不敢使用编译时耗较高的优化技术。

Sun Hospot VM是现在使用最广的虚拟机，提供热点代码探测技术，可以通过执行计数器找到最具有编译价值的代码，然后通知JIT编译器以方法为单位进行编译。通过编译器与解释器协同工作，在相应时间与执行性能中取得平衡，可以执行更多的代码优化技术。

在Java的展望里，提到了模块化，这个在Java 9中已经实现了；混合语言，一个项目中不同的应用层使用不同的编程语言，不过这样真的好么，维护性很低啊；多核并行，提高单机的性能；64位虚拟机，书上说64位虚拟机要付出更大的代价，比如更高的内存消耗，但是在[stackoverflow](https://stackoverflow.com/questions/4931304/why-is-the-64bit-jvm-faster-than-the-32bit-one?tdsourcetag=s_pctim_aiomsg) 上提出他的64位要比32位性能更号，还没有实践过。

自己编译JDK，这个就比较坑了，最开始想和书上装7，后来发现要6的环境，索性就编译9，然后apt-get安装8。Linux下在configure检查下环境没有问题，但是make之后就报错，查了好久，发现是版本问题，glibc >= 2.24的情况下，readdir_r方法被deprecated了，不支持了，openjdk在11修复了问题，之前的不管了。

>8可以修改./hotspot/make/linux/makefiles/gcc.make的WARNINGS_ARE_ERRORS = -Werro，注释掉或者改为-Wno_all。
9的话是没有的，可以bash configure --disable-warnings-as-errors --enable-debug解决

## 第二部分 自动内存管理机制

### 第二章 Java内存区域与内存溢出异常

Java虚拟机在执行Java程序的时会把它管理的内存划分不同的区域，每个区域有不同的用途，包括以下几个运行时数据区域，如下图  
![member.png](https://i.loli.net/2019/11/30/kSrPAahcdTBQRqM.png)  
程序计数器  
PC寄存器，在会汇编里学的，是存放下一条指令的位置，也就是运行前指针+1，而在JVM里是当前指令的位置，也就是运行完指针+1。  
JVM多线程是通过线程轮流切换并分配处理器执行时间的方式，这个和操作系统相近，单核CPU一次只能运行一个进程，而在运行的Java进程中会再分线程，一次只能执行一个线程。为了在线程切换后能够恢复正确的执行位置，每个线程都要有自己的程序计数器，且相互不会有影响，也就是“线程私有”的内存。  
执行Java方法存的是正在执行的指令地址，执行Native方式则为空。  
Java虚拟机栈  
Java虚拟机栈也是线程私有，生命周期与线程相同，其描述的是Java方法执行的内存模型，即每个方法在执行时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到完成，对应了一个栈帧在虚拟机栈中的入栈出栈。最好的理解就是方法包含方法，一个方法调用的方法没有完成，该方法的栈帧上面始终有调用方法的栈帧。  
局部变量表存放编译器可知的各种基本数据类型、对象引用和returnAddress类型。64位长度的long和double会占用两个局部变量空间，其他类型占1个。局部变量表所需要的内存空间在编译期间完成分配，在运行期间不会改变局部变量表大小。  
虚拟机栈规定了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError；如果可以动态扩展，且扩展时无法申请到足够的内存，就会抛出OOM  

本地方法栈  
和虚拟机栈相似，不同在于一个是执行Java的，一个是执行Native方法的。HotSpot把这两个栈合二为一。  

Java堆  
Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建，其唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配的。  
Java堆是垃圾回收器管理的主要区域，从回收的角度来看，基于现在收集器采用的分代收集，可以分为新生代和老年代，再细分可以再分Eden区、From Survivor区、To Survivor区；从内存分配来看，可能划分出多个线程私有的分配缓冲区。  
Java堆可以在物理空间上不连续，只要逻辑上连续即可。既可以实现固定大小，也可以扩展（-Xmx和-Xms），我记得阿里规范上要求固定大小。如果堆中没有内存，抛出OOM。  
